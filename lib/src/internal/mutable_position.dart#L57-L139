  void makeNormalMove(Square from, Square to, [Role? promotion]) {
    final piece = boardArray[from.value]!;
    final capturedPiece = boardArray[to.value];
    
    // 1. Detect special moves BEFORE removing any pieces
    Square? nextEpSquare;
    CastlingSide? castlingSide;
    if (piece.role == Role.pawn) {
      if ((from.value - to.value).abs() == 16) {
        nextEpSquare = Square((from.value + to.value) >>> 1);
      }
    } else if (piece.role == Role.king) {
      castlingSide = _getCastlingSideRaw(from, to, forceToPiece: capturedPiece);
    }

    // 2. Handle captured piece
    Square? capturedSquare = to;
    Piece? actualCaptured = capturedPiece;

    if (piece.role == Role.pawn && to == epSquare) {
      capturedSquare = Square(to.value + (turn == Side.white ? -8 : 8));
      actualCaptured = boardArray[capturedSquare.value];
      _stack.add(UndoState(epSquare, castlingRights, halfmoves, actualCaptured, capturedSquare));
      _removePiece(capturedSquare, actualCaptured!);
    } else {
      _stack.add(UndoState(epSquare, castlingRights, halfmoves, capturedPiece, castlingSide != null ? null : to, castlingSide));
      if (capturedPiece != null) {
        _removePiece(to, capturedPiece);
      }
    }

    // 3. Move the piece
    if (turn == Side.black) fullmoves++;
    _removePiece(from, piece);

    // 4. Update state
    if (actualCaptured != null || piece.role == Role.pawn) {
      halfmoves = 0;
    } else {
      halfmoves++;
    }

    // 5. Execute special logic
    if (castlingSide != null) {
      final rookFrom = (capturedPiece != null &&
              capturedPiece.role == Role.rook &&
              capturedPiece.color == turn)
          ? to
          : _getRookFrom(turn, castlingSide)!;
      final rook = (rookFrom == to) ? capturedPiece! : boardArray[rookFrom.value]!;
      
      if (rookFrom != to) {
        _removePiece(rookFrom, rook);
      }
      
      _stack.last = _stack.last.copyWith(capturedSquare: rookFrom);

      final kingTo = kingCastlesTo(turn, castlingSide);
      final rookTo = rookCastlesTo(turn, castlingSide);

      _addPiece(rookTo, rook);
      _addPiece(kingTo, promotion != null ? piece.copyWith(role: promotion) : piece);

      epSquare = null;
      castlingRights = castlingRights.diff(SquareSet.backrankOf(turn));
      turn = turn.opposite;
      return;
    }

    if (capturedPiece?.role == Role.rook) {
      castlingRights = castlingRights.withoutSquare(to);
    }
    if (piece.role == Role.rook) {
      castlingRights = castlingRights.withoutSquare(from);
    } else if (piece.role == Role.king) {
      castlingRights = castlingRights.diff(SquareSet.backrankOf(turn));
    }

    final movingPiece = promotion != null ? piece.copyWith(role: promotion) : piece;
    _addPiece(to, movingPiece);
    epSquare = nextEpSquare;
    turn = turn.opposite;
  }
